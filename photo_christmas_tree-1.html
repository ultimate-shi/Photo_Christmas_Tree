<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç²’å­åœ£è¯æ ‘ä¸ç…§ç‰‡å±•ç¤º</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ‘„åƒå¤´å°çª— */
        #video-element {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1);
            z-index: 2;
            opacity: 0.6;
            border: 2px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        /* åŠ è½½æç¤º */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 20px;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px #00ff88;
        }

        /* ç•Œé¢ UI å®¹å™¨ */
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        /* æŒ‰é’®æ ·å¼ */
        .glass-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 24px;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            transition: all 0.3s;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .glass-btn:hover { 
            background: rgba(255, 255, 255, 0.25); 
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,255,136,0.2);
        }

        /* éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† */
        #file-input { display: none; }

        #instruction {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            z-index: 2;
            pointer-events: none;
            font-size: 14px;
        }
    </style>
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">ğŸ„ æ­£åœ¨ç§æ¤åœ£è¯æ ‘ & å¯åŠ¨æ‘„åƒå¤´...</div>
    <div id="instruction">åŒæ‰‹å¼ åˆæ§åˆ¶æ ‘çš„å¤§å° Â· ä¸Šä¼ ç…§ç‰‡æ”¾å…¥æ ‘å¿ƒ</div>
    
    <div id="canvas-container"></div>
    <video id="video-element" playsinline></video>

    <!-- åº•éƒ¨æ§åˆ¶æ  -->
    <div id="ui-container">
        <button class="glass-btn" onclick="document.getElementById('file-input').click()">ğŸ“· ä¸Šä¼ ç…§ç‰‡</button>
        <button class="glass-btn" id="fullscreen-btn">å…¨å±ä½“éªŒ</button>
    </div>
    
    <input type="file" id="file-input" accept="image/*">

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, particles, geometry, material;
        let photoMesh = null; // ç”¨äºå­˜å‚¨ç…§ç‰‡çš„ Mesh
        let controls;
        const PARTICLE_COUNT = 18000;
        const PARTICLE_SIZE = 0.18;
        
        // å½¢çŠ¶æ•°æ®
        const shapes = {
            tree: [],
            heart: [],
            sphere: []
        };
        
        // çŠ¶æ€ç®¡ç†
        const state = {
            currentShape: 'tree',
            color: '#00ff88', // é»˜è®¤åœ£è¯ç»¿
            handDistance: 0.8, // åˆå§‹å¼ å¼€çŠ¶æ€
            photoScale: 1.0,
            autoRotate: true
        };

        // ç²’å­ç›®æ ‡ä½ç½®ç¼“å†²
        let targetPositions = new Float32Array(PARTICLE_COUNT * 3);

        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 16);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = state.autoRotate;
            controls.autoRotateSpeed = 1.0;

            // åˆ›å»ºç¯å…‰ï¼ˆä¸ºäº†ç…§äº®ç…§ç‰‡ï¼‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 5, 10);
            scene.add(dirLight);

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            // ç”Ÿæˆå½¢çŠ¶æ•°æ®
            generateShapeData();
            
            // åˆå§‹è®¾ç½®ä¸ºåœ£è¯æ ‘
            transitionToShape('tree');

            // ç›‘å¬äº‹ä»¶
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
        }

        // --- 2. ç²’å­ä¸çº¹ç† ---
        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            
            // åˆå§‹éšæœºæ•£è½
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 60;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // ç”Ÿæˆåœ†å½¢å…‰ç‚¹çº¹ç†
            const sprite = getSprite();

            material = new THREE.PointsMaterial({
                color: state.color,
                size: PARTICLE_SIZE,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9,
                vertexColors: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.6)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- 3. å½¢çŠ¶ç®—æ³• (æ ¸å¿ƒï¼šåœ£è¯æ ‘) ---
        function generateShapeData() {
            // 1. åœ£è¯æ ‘ (Spiral Cone)
            shapes.tree = [];
            const treeHeight = 14;
            const maxRadius = 5.5;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // çº¿æ€§åˆ†å¸ƒé«˜åº¦ï¼Œä½†ç¨å¾®èšé›†åœ¨åº•éƒ¨
                const hPercent = i / PARTICLE_COUNT; 
                const y = (hPercent * treeHeight) - (treeHeight / 2); // å±…ä¸­Yè½´
                
                // åŠå¾„éšé«˜åº¦å‡å° (Cone)
                // Math.pow ç¨å¾®å¼¯æ›²è¾¹ç¼˜è®©å®ƒæ›´åƒè‡ªç„¶æ ‘æœ¨
                let radius = (1 - hPercent) * maxRadius;
                
                // èºæ—‹è§’åº¦ (Golden Angle)
                const angle = i * 2.4; 

                // æ·»åŠ éšæœºæ€§è®©æ ‘å¶è“¬æ¾
                const rRandom = radius + (Math.random() - 0.5) * 0.5;
                
                // æ ‘èº«
                let x = Math.cos(angle) * rRandom;
                let z = Math.sin(angle) * rRandom;

                // è£…é¥°ï¼šæœ‰æå°‘éƒ¨åˆ†ç²’å­ä½œä¸ºâ€œé›ªèŠ±â€æˆ–â€œæ˜Ÿå…‰â€é£˜åœ¨å¤–é¢
                if (Math.random() > 0.97) {
                    x *= 1.5;
                    z *= 1.5;
                }

                shapes.tree.push(x, y - 1, z); // y-1 ä¸ºäº†ç¨å¾®ä¸‹æ²‰ä¸€ç‚¹
            }

            // 2. çˆ±å¿ƒ (ç”¨äºåˆ‡æ¢æ¼”ç¤º)
            shapes.heart = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.random(); 
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const scale = 0.35;
                shapes.heart.push(x * scale * Math.sqrt(r), y * scale * Math.sqrt(r), (Math.random()-0.5)*3);
            }
        }

        function transitionToShape(shapeName) {
            state.currentShape = shapeName;
            const targetData = shapes[shapeName];
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targetPositions[i] = targetData[i] || 0;
            }
        }

        // --- 4. å›¾ç‰‡ä¸Šä¼ å¤„ç† ---
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    createPhotoMesh(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createPhotoMesh(image) {
            // å¦‚æœå·²æœ‰å›¾ç‰‡ï¼Œå…ˆç§»é™¤
            if (photoMesh) {
                scene.remove(photoMesh);
                photoMesh.geometry.dispose();
                photoMesh.material.map.dispose();
                photoMesh.material.dispose();
            }

            const texture = new THREE.Texture(image);
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.needsUpdate = true;

            // ä¿æŒå®½é«˜æ¯”
            const aspect = image.width / image.height;
            const baseSize = 4; // åŸºç¡€å¤§å°
            const geometry = new THREE.PlaneGeometry(baseSize * aspect, baseSize);
            
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            photoMesh = new THREE.Mesh(geometry, material);
            scene.add(photoMesh);

            // åˆå§‹åŠ¨ç”»æ•ˆæœ
            photoMesh.scale.set(0, 0, 0);
        }

        // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks;
                    
                    // è®¡ç®—è·ç¦»é€»è¾‘
                    let dist = 0.5;
                    if (landmarks.length === 2) {
                        // åŒæ‰‹è·ç¦»
                        const h1 = landmarks[0][0];
                        const h2 = landmarks[1][0];
                        dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));
                        // æ˜ å°„ä¼˜åŒ–ï¼š0.1-0.8 -> 0.2-2.0
                        dist = Math.max(0.2, Math.min(dist * 3, 2.5));
                    } else {
                        // å•æ‰‹æåˆ
                        const thumb = landmarks[0][4];
                        const index = landmarks[0][8];
                        const pinch = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                        dist = (pinch * 5) + 0.4; // ç®€å•æ˜ å°„
                    }
                    
                    // å¹³æ»‘æ’å€¼æ›´æ–°
                    state.handDistance += (dist - state.handDistance) * 0.1;
                } else {
                    // æ— æ‰‹åŠ¿æ—¶æ¢å¤é»˜è®¤å‘¼å¸çŠ¶æ€ (æ¨¡æ‹Ÿ 0.8 åˆ° 1.0 çš„æµ®åŠ¨)
                    const idle = 0.8 + Math.sin(Date.now() * 0.002) * 0.1;
                    state.handDistance += (idle - state.handDistance) * 0.05;
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640,
                height: 480
            });
            
            cameraUtils.start().then(() => {
                document.getElementById('loader').style.opacity = 0;
            });
        }

        // --- 6. GUI è®¾ç½® ---
        function initGUI() {
            const gui = new GUI({ title: 'æ§åˆ¶å°' });
            gui.domElement.style.top = '20px';
            gui.domElement.style.right = '20px';

            const shapeFolder = gui.addFolder('æ ·å¼');
            shapeFolder.add({ shape: 'tree' }, 'shape', {'åœ£è¯æ ‘': 'tree', 'çˆ±å¿ƒ': 'heart'}).name('å½¢çŠ¶').onChange(v => {
                transitionToShape(v);
                if(v === 'tree') state.color = '#00ff88';
                if(v === 'heart') state.color = '#ff4466';
                material.color.set(state.color);
            });
            
            shapeFolder.addColor(state, 'color').name('ç²’å­é¢œè‰²').onChange(v => material.color.set(v));
            shapeFolder.add(material, 'size', 0.05, 0.5).name('ç²’å­å¤§å°');
            
            const photoFolder = gui.addFolder('ç…§ç‰‡è®¾ç½®');
            photoFolder.add(state, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬').onChange(v => controls.autoRotate = v);
        }

        // --- 7. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const positions = particles.geometry.attributes.position.array;
            
            // æ‰©æ•£ç³»æ•°ï¼šæ‰‹åŠ¿æ§åˆ¶
            const spread = state.handDistance;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                
                // è·å–ç›®æ ‡ä½ç½®å¹¶åº”ç”¨æ‰©æ•£ç³»æ•°
                const tx = targetPositions[ix] * spread;
                const ty = targetPositions[ix+1] * spread;
                const tz = targetPositions[ix+2] * spread;

                // ç²’å­ Lerp ç§»åŠ¨
                positions[ix] += (tx - positions[ix]) * 0.08;
                positions[ix+1] += (ty - positions[ix+1]) * 0.08;
                positions[ix+2] += (tz - positions[ix+2]) * 0.08;

                // åœ£è¯æ ‘ç‰¹æ•ˆï¼šé—ªçƒ
                if (state.currentShape === 'tree' && Math.random() > 0.995) {
                   // å¯ä»¥åœ¨è¿™é‡Œåšé¢œè‰²é—ªçƒé€»è¾‘ï¼Œå¦‚æœä½¿ç”¨ VertexColors
                   // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬è®©å®ƒè½»å¾®æŠ–åŠ¨æ¨¡æ‹Ÿé—ªçƒ
                   positions[ix] += (Math.random()-0.5) * 0.2;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;

            // ç…§ç‰‡é€»è¾‘
            if (photoMesh) {
                // ç…§ç‰‡é¢å‘ç›¸æœº
                photoMesh.lookAt(camera.position);
                
                // ç…§ç‰‡å¤§å°è·Ÿéšæ‰‹åŠ¿ï¼ˆåœ¨æ ‘çš„ä¸­å¿ƒï¼‰
                // é™åˆ¶æœ€å°å¤§å°ï¼Œä»¥å…å®Œå…¨æ¶ˆå¤±
                const targetScale = Math.max(0.5, spread * 0.8);
                
                photoMesh.scale.x += (targetScale - photoMesh.scale.x) * 0.1;
                photoMesh.scale.y += (targetScale - photoMesh.scale.y) * 0.1;
                photoMesh.scale.z += (targetScale - photoMesh.scale.z) * 0.1;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        }

        // å¯åŠ¨
        initThree();
        initGUI();
        initMediaPipe();
        animate();

    </script>
</body>
</html>